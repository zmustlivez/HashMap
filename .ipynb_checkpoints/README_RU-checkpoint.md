# HashMap
| [ENG](https://github.com/A1eksMa/HashMap/blob/main/README.md) | [RU](https://github.com/A1eksMa/HashMap/blob/main/README_RU.md) | 

## Практика в Java. Пишем свой собственный HashMap Collections Framework.
См. [ENG](https://github.com/A1eksMa/HashMap/blob/main/README.md) версию.

### Введение
Это учебный проект, попытка написать свою собственную коллекцию на базе Java Collections Framework. Цели проекта - получить практику в написании ООП кода на Java, поглубже разобраться в API Collections Framework. Итоговая задача - написать немного упрощенный HashMap, или коллекцию, близкую к нему по своему поведению и структуре.

### Описание структуры данных:
 - на верхнем уровне: нативный массив Java, с начальной длиной `len`.  
 - на следующем уровне, элементы массива - бакеты - содержат ноды организованные в виде:
   - либо односвязанного списка,
   - либо дерева.

    В составе каждой ноды содержится:
   - хэш ключа `h`,
    - ключ `k`,
    - значение `v`.

Количество нод в бакете обозначим за `n`, количество нод во всех бакетах - за `sum(n)` (здесь и далее).

### Начальное состояние:
1. Пусть начальная длина массива (количество бакетов)
```java
    int len = 2;
```
2. Начальный тип элемента в бакете - односвязанный список с 0 элементов.
3. Внутренняя константа порогового значения `Q` (для упрощения примем ее единой для всех случаев порога изменения).

Целое число от 2 до любой степени 2.

Для примера, здесь и далее будем использовать:
```java
   int `Q` = 128;
```


### Полученная структура должна обладать следующим поведением:
1. Массив верхней структуры должен динамически удваивать свою длину, в случаях когда соотношении общего количества нод `sum(n)` к длине массива `len` достигает порогового значения `Q`. Удвоение длины массива происходит до достижения порогового значения len = Q.

Условие перехода к удвоению длины массива:
```java
    if (sum(n) / len > Q) {}
```

2. Тип элемента бакета должен изменяться с односвязанного списка на дерево при превышении количеством элементов в бакете `n` порогового значения `Q` и возвращаться к типу односвязанного списка при количестве элементов в бакете `n` меньше порогового значения `Q`.

Условие перестроения способа организации нод в бакете (с односвязанного списка на дерево):
```java
    if (n > Q) {} else {}
```

3. При добавлении элемента `e` , выбор бакета (индекса `i` массива верхнего уровня) происходит на основании рассчитаного хэша элемента:
```java
   h = e.hashCode()
```
по формулам:
```java
    d = (max_int - min_int + 1)
    
    i = (h - min_int) / ( d / len )
```
где:
- i - индекс массива (он же - номер бакета);
- d - количество возможных значений хэша;
- max_int - максимально возможное значение хэша, 2_147_483_647;
- min_int - минимально возможное значение хэша, -2_147_483_648;

4. Перестроение типа нод в бакете с односвязанного списка на дерево происходит только *после* достижения массивом верхнего уровня своей предельной длины:
```java
    len = Q
```

До достижения этого момента при превышении количеством нод в бакете `n` порогового значения `Q` предпринимается попытка уменьшения количества нод в бакете за счет удвоения длины массива верхнего уровня (т.е. за счет увеличения количества бакетов).

При изменении количества бакетов происходит пересчет хэшей в нодах и перераспределение нод между бакетами.

5. Количество нод во всех бакетах `sum(n)` должно быть получено за константное время.
6. При поиске элемента `e` должен быть:
- определен его хэш `h = e.hashCode()`,
- вычислен целевой бакет (индекс `i` массива верхнего уровня),
- произведен поиск в целевом бакете на основании равенства хэшей,
- в случае обнаружения в бакете элементов с совпадающими хэшами (коллизии) произведен поиск в нодах с коллизией хэша по значению ключа.

7. Должен быть реализован стандартный набор методов:

 	containsKey
    containsValue
    get(Object key)
    keySet()
    put(K key, V value)
    remove(Object key)
    size()

